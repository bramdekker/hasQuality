package com.bramdekker.main.util;

import antlr.HaskellParser;
import antlr.HaskellParserBaseListener;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import java.util.HashMap;
import java.util.Map;

/** Custom listener for antlr parsetrees to collect data for Halstead metrics. */
public class CustomListener extends HaskellParserBaseListener {
  // TODO: change to random string to avoid occurrence as id.
  private static final String literalKey = "00literal";
  private final Map<String, Integer> operatorMap;
  private final Map<String, Integer> operandMap;

  public CustomListener() {
    this.operatorMap = new HashMap<>();
    this.operandMap = new HashMap<>();
  }

  /**
   * Use the listener to walk the parse tree and populate the dictionaries.
   *
   * @param tree ParseTree generated by antlr.
   */
  public void createHalsteadMaps(ParseTree tree) {
    new ParseTreeWalker().walk(this, tree);
  }

  /**
   * Calculates the halstead length based on the dictionaries.
   *
   * @return long representing the sum of total occurrences of operands and operators.
   */
  public long getHalsteadLength() {
    long length = 0;
    for (int number : this.operandMap.values()) {
      length += number;
    }
    for (int number : this.operatorMap.values()) {
      length += number;
    }
    return length;
  }

  /**
   * Calculates the halstead vocabulary based on the dictionaries.
   *
   * @return long representing the sum of unique occurrences of operands and operators.
   */
  public long getHalsteadVocabulary() {
    return operandMap.size() + operatorMap.size();
  }

  /**
   * Update the operand dictionary when an occurrence of key is found.
   *
   * @param key String representing the operand that is found.
   */
  public void updateOperandMap(String key) {
    if (operandMap.containsKey(key)) {
      operandMap.put(key, operandMap.get(key) + 1);
    } else {
      operandMap.put(key, 1);
    }
  }

  /**
   * Update the operator dictionary when an occurrence of key is found.
   *
   * @param key String representing the operator that is found.
   */
  public void updateOperatorMap(String key) {
    if (operatorMap.containsKey(key)) {
      operatorMap.put(key, operatorMap.get(key) + 1);
    } else {
      operatorMap.put(key, 1);
    }
  }

  @Override
  public void enterLiteral(HaskellParser.LiteralContext ctx) {
    // Literals do not have to be counted for uniqueness.
    updateOperandMap(literalKey);
  }

  @Override
  public void enterVarid(HaskellParser.VaridContext ctx) {
    String key = ctx.getChild(0).getText();
    updateOperandMap(key);
  }

  @Override
  public void enterConid(HaskellParser.ConidContext ctx) {
    if (!(ctx.getParent() instanceof HaskellParser.ModidContext)) {
      String key = ctx.getChild(0).getText();
      updateOperandMap(key);
    }
  }

  @Override
  public void enterRhs(HaskellParser.RhsContext ctx) {
    updateOperatorMap("=");
  }

  @Override
  public void enterSigdecl(HaskellParser.SigdeclContext ctx) {
    updateOperatorMap("::");
  }

  @Override
  public void enterTypedoc(HaskellParser.TypedocContext ctx) {
    updateOperatorMap("->");
  }

  @Override
  public void enterVarsym(HaskellParser.VarsymContext ctx) {
    updateOperatorMap("-");
  }

  @Override
  public void enterAscSymbol(HaskellParser.AscSymbolContext ctx) {
    // Not all asc symbols are operators. So we have to use if-else.
    // TODO: check all boolean operators.
    if (ctx.Ampersand() != null) {
      updateOperatorMap("&");
    } else if (ctx.Asterisk() != null) {
      updateOperatorMap("*");
    } else if (ctx.Percent() != null) {
      updateOperatorMap("%");
    } else if (ctx.Plus() != null) {
      updateOperatorMap("+");
    } else if (ctx.Divide() != null) {
      updateOperatorMap("/");
    } else if (ctx.Pipe() != null) {
      updateOperatorMap("|");
    } else if (ctx.Caret() != null) {
      updateOperatorMap("^");
    }
  }
}
